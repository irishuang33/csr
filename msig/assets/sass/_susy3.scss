// Sass Utilities
// ==============
// - Susy Error Output Override [variable]
// - Susy Error [function]



// Susy Error Output Override
// --------------------------
/// Turn off error output for testing
/// @group x-utility
/// @access private
$_susy-error-output-override: false !default;



// Susy Error
// ----------
/// Optionally return error messages without failing,
/// as a way to test error cases
///
/// @group x-utility
/// @access private
///
/// @param {string} $message -
///   A useful error message, explaining the problem
/// @param {string} $source -
///   The original source of the error for debugging
/// @param {bool} $override [$_susy-error-output-override] -
///   Optionally return the error rather than failing
/// @return {string} -
///   Combined error with source and message
/// @throws When `$override == true`
@function _susy-error(
  $message,
  $source,
  $override: $_susy-error-output-override
) {
  @if $override {
    @return 'ERROR [#{$source}] #{$message}';
  }

  @error '[#{$source}] #{$message}';
}


// Su Is Comparable
// ----------------
/// Check that the units in a grid are comparable
///
/// @group x--validation
/// @access private
///
/// @param {numbers} $lengths… -
///   Arglist of all the number values to compare
///   (columns, gutters, span, etc)
///
/// @return {'fluid' | 'static' | false} -
///   The type of span (fluid or static) when units match,
///   or `false` for mismatched units
@function _su-is-comparable(
  $lengths...
) {
  $first: nth($lengths, 1);

  @if (length($lengths) == 1) {
    @return if(unitless($first), 'fluid', 'static');
  }

  @for $i from 2 through length($lengths) {
    $comp: nth($lengths, $i);

    $fail: not comparable($first, $comp);
    $fail: $fail or (unitless($first) and not unitless($comp));
    $fail: $fail or (unitless($comp) and not unitless($first));

    @if $fail {
      @return false;
    }
  }

  @return if(unitless($first), 'fluid', 'static');
}


// Su Map Add Units
// ----------------
/// The calc features use a map of units and values
/// to compile the proper algorythm.
/// This function adds a new value to any comparable existing unit/value,
/// or adds a new unit/value pair to the map
///
/// @group x-utility
/// @access private
///
/// @param {map} $map -
///   A map of unit/value pairs, e.g. ('px': 120px)
/// @param {length} $value -
///   A new length to be added to the map
/// @return {map} -
///   The updated map, with new value added
///
/// @example scss -
///   $map: (0px: 120px);
///   $map: _su-map-add-units($map, 1in); // add a comparable unit
///   $map: _su-map-add-units($map, 3vw); // add a new unit
///
///   @each $units, $value in $map {
///     /* #{$units}: #{$value} */
///   }
@function _su-map-add-units(
  $map,
  $value
) {
  $unit: $value * 0;
  $has: map-get($map, $unit) or 0;

  @if ($has == 0) {
    @each $try, $could in $map {
      $match: comparable($try, $value);
      $unit: if($match, $try, $unit);
      $has: if($match, $could, $has);
    }
  }

  @return map-merge($map, ($unit: $has + $value));
}


// Susy Flatten
// ------------
/// Flatten a multidimensional list
///
/// @group x-utility
/// @access private
///
/// @param {list} $list -
///   The list to be flattened
/// @return {list} -
///   The flattened list
///
/// @example scss -
///   $list: 120px (30em 30em) 120px;
///   /* #{_susy-flatten($list)} */
@function _susy-flatten(
  $list
) {
  $flat: ();

  // Don't iterate over maps
  @if (type-of($list) == 'map') {
    @return $list;
  }

  // Iterate over lists (or single items)
  @each $item in $list {
    @if (type-of($item) == 'list') {
      $item: _susy-flatten($item);
      $flat: join($flat, $item);
    } @else {
      $flat: append($flat, $item);
    }
  }

  // Return flattened list
  @return $flat;
}


// Validation
// ==========
// - su-valid-columns [function]
// - su-valid-gutters [function]
// - su-valid-spread [function]
// - su-valid-location [function]
// - su-is-comparable [function]
// - su-needs-calc [function]



// Valid Span
// ----------
/// Check that the `span` argument
/// is a number, length, or column-list
///
/// @group x--validation
///
/// @param {number | list} $span -
///   Number of columns, or length of span
///
/// @return {number | list} -
///   Validated `$span` number, length, or columns list
///
/// @throw
///   when span value is not a number, or valid column list
@function su-valid-span(
  $span
) {
  $type: type-of($span);
  @if ($type == 'number') {
    @return $span;
  } @else if ($type == 'list') and su-valid-columns($span, 'silent-failure') {
    @return $span;
  }

  $actual: '[#{type-of($span)}] `#{inspect($span)}`';
  @return _susy-error(
    '#{$actual} is not a valid number, length, or column-list for $span.',
    'su-valid-span');
}



// Valid Columns
// -------------
/// Check that the `columns` argument is a valid
/// list of column-lengths
///
/// @group x--validation
///
/// @param {list} $columns -
///   List of column-lengths
/// @param {bool} $silent-failure [true] -
///   Set false to return null on failure
///
/// @return {list} -
///   Validated `$columns` list
///
/// @throw
///   when column value is not a valid list of numbers
@function su-valid-columns(
  $columns,
  $silent-failure: false
) {
  @if (type-of($columns) == 'list') {
    $fail: false;

    @each $col in $columns {
      @if (type-of($col) != 'number') {
        $fail: true;
      }
    }

    @if not $fail {
      @return $columns;
    }
  }

  // Silent Failure
  @if $silent-failure {
    @return null;
  }

  // Error Message
  $actual: '[#{type-of($columns)}] `#{inspect($columns)}`';

  @return _susy-error(
    '#{$actual} is not a valid list of numbers for $columns.',
    'su-valid-columns');
}



// Valid Gutters
// -------------
/// Check that the `gutters` argument is a valid number
///
/// @group x--validation
///
/// @param {number} $gutters -
///   Width of a gutter
///
/// @return {number} -
///   Validated `$gutters` number
///
/// @throw
///   when gutter value is not a number
@function su-valid-gutters(
  $gutters
) {
  $type: type-of($gutters);

  @if ($type == 'number') {
    @return $gutters;
  }

  $actual: '[#{$type}] `#{inspect($gutters)}`';
  @return _susy-error(
    '#{$actual} is not a number or length for $gutters.',
    'su-valid-gutters');
}



// Valid Spread
// ------------
/// Check that the `spread` argument is a valid
/// intiger between `-1` and `1`
///
/// @group x--validation
///
/// @param {0 | 1 | -1} $spread -
///   Number of gutters to include in a span,
///   relative to the number columns
///
/// @return {0 | 1 | -1} -
///   Validated `$spread` number
///
/// @throw
///   when spread value is not a valid spread
@function su-valid-spread(
  $spread
) {
  @if index(0 1 -1, $spread) {
    @return $spread;
  }

  $actual: '[#{type-of($spread)}] `#{inspect($spread)}`';
  @return _susy-error(
    '#{$actual} is not a normalized [0 | 1 | -1] value for `$spread`.',
    'su-valid-spread');
}



// Valid Location
// --------------
/// Check that the `location` argument is a valid number,
/// within the scope of available columns
///
/// @group x--validation
///
/// @param {number} $span -
///   Number of grid-columns to be spanned
/// @param {integer | string} $location -
///   Starting (1-indexed) column-position of that span
/// @param {list} $columns -
///   List of available columns in the grid
///
/// @return {integer} -
///   Validated `$location` intiger
///
/// @throw
///   when location value is not a valid index,
///   given the context and span.
@function su-valid-location(
  $span,
  $location,
  $columns
) {
  $count: length($columns);

  @if $location {
    @if (type-of($location) != 'number') or (not unitless($location)) {
      $actual: '[#{type-of($location)}] `#{$location}`';
      @return _susy-error(
        '#{$actual} is not a unitless number for $location.',
        'su-valid-location');
    } @else if (round($location) != $location) {
      @return _susy-error(
        'Location (`#{$location}`) must be a 1-indexed intiger position.',
        'su-valid-location');
    } @else if ($location > $count) or ($location < 1) {
      @return _susy-error(
        'Position `#{$location}` does not exist in grid `#{$columns}`.',
        'su-valid-location');
    } @else if ($location + $span - 1 > $count) {
      $details: 'grid `#{$columns}` for span `#{$span}` at `#{$location}`';
      @return _susy-error(
        'There are not enough columns in #{$details}.',
        'su-valid-location');
    }
  }

  @return $location;
}


// Grids
// =====
// - su-span [function]
// - su-gutter [function]
// - su-slice [function]
// - _su-sum [function]
// - _su-calc-span [function]
// - _su-calc-sum [function]
// - _su-needs-calc-output [function]


// Su Span
// -------
/// Calculates and returns a CSS-ready span width,
/// based on normalized span and context data –
/// a low-level version of `susy-span`,
/// with all of the logic and none of the syntax sugar.
///
/// - Grids defined with unitless numbers will return `%` values.
/// - Grids defined with comparable units
///   will return a value in the units provided.
/// - Grids defined with a mix of units,
///   or a combination of untiless numbers and unit-lengths,
///   will return a `calc()` string.
///
/// @group su-math
/// @see susy-span
///
/// @param {number | list} $span -
///   Number or list of grid columns to span
/// @param {list} $columns -
///   List of columns available
/// @param {number} $gutters -
///   Width of a gutter in column-comparable units
/// @param {0 | 1 | -1} $spread -
///   Number of gutters spanned,
///   relative to `span` count
/// @param {0 | 1 | -1} $container-spread [$spread] -
///   Number of gutters spanned,
///   relative to `columns` count
/// @param {integer} $location [1] -
///   Optional position of sub-span among full set of columns
///
/// @return {length} -
///   Relative or static length of a span on the grid
@function su-span(
  $span,
  $columns,
  $gutters,
  $spread,
  $container-spread: $spread,
  $location: 1
) {
  $span: su-valid-span($span);
  $columns: su-valid-columns($columns);
  $gutters: su-valid-gutters($gutters);
  $spread: su-valid-spread($spread);

  @if (type-of($span) == 'number') {
    @if (not unitless($span)) {
      @return $span;
    }

    $location: su-valid-location($span, $location, $columns);
    $span: su-slice($span, $columns, $location, $validate: false);
  }

  @if _su-needs-calc-output($span, $columns, $gutters, not 'validate') {
    @return _su-calc-span($span, $columns, $gutters, $spread, $container-spread, not 'validate');
  }

  $span-width: _su-sum($span, $gutters, $spread, $validate: false);

  @if unitless($span-width) {
    $container-spread: su-valid-spread($container-spread);
    $container: _su-sum($columns, $gutters, $container-spread, $validate: false);
    @return percentage($span-width / $container);
  }

  @return $span-width;
}


// Su Gutter
// ---------
/// Calculates and returns a CSS-ready gutter width,
/// based on normalized grid data –
/// a low-level version of `susy-gutter`,
/// with all of the logic and none of the syntax sugar.
///
/// - Grids defined with unitless numbers will return `%` values.
/// - Grids defined with comparable units
///   will return a value in the units provided.
/// - Grids defined with a mix of units,
///   or a combination of untiless numbers and unit-lengths,
///   will return a `calc()` string.
///
/// @group su-math
/// @see susy-gutter
///
/// @param {list} $columns -
///   List of columns in the grid
/// @param {number} $gutters -
///   Width of a gutter in column-comparable units
/// @param {0 | 1 | -1} $container-spread -
///   Number of gutters spanned,
///   relative to `columns` count
///
/// @return {length} -
///   Relative or static length of one gutter in a grid
@function su-gutter(
  $columns,
  $gutters,
  $container-spread
) {
  @if (type-of($gutters) == 'number') {
    @if ($gutters == 0) or (not unitless($gutters)) {
      @return $gutters;
    }
  }

  @if _su-needs-calc-output($gutters, $columns, $gutters, not 'validate') {
    @return _su-calc-span($gutters, $columns, $gutters, -1, $container-spread, not 'validate');
  }

  $container: _su-sum($columns, $gutters, $container-spread);
  @return percentage($gutters / $container);
}


// Su Slice
// --------
/// Returns a list of columns
/// based on a given span/location slice of the grid –
/// a low-level version of `susy-slice`,
/// with all of the logic and none of the syntax sugar.
///
/// @group su-math
/// @see susy-slice
///
/// @param {number} $span -
///   Number of grid columns to span
/// @param {list} $columns -
///   List of columns in the grid
/// @param {number} $location [1] -
///   Starting index of a span in the list of columns
/// @param {bool} $validate [true] -
///   Check that arguments are valid before proceeding
///
/// @return {list} -
///   Subset list of grid columns, based on span and location
@function su-slice(
  $span,
  $columns,
  $location: 1,
  $validate: true
) {
  @if $validate {
    $columns: su-valid-columns($columns);
    $location: su-valid-location($span, $location, $columns);
  }

  $floor: floor($span);
  $sub-columns: ();

  @for $i from $location to ($location + $floor) {
    $sub-columns: append($sub-columns, nth($columns, $i));
  }

  @if $floor != $span {
    $remainder: $span - $floor;
    $column: $location + $floor;
    $sub-columns: append($sub-columns, nth($columns, $column) * $remainder);
  }

  @return $sub-columns;
}


// Su Sum
// ------
/// Get the total sum of column-units in a layout.
///
/// @group su-math
/// @access private
///
/// @param {list} $columns -
///   List of columns in the grid
/// @param {number} $gutters -
///   Width of a gutter in column-comparable units
/// @param {0 | 1 | -1} $spread -
///   Number of gutters spanned,
///   relative to `columns` count
/// @param {bool} $validate [true] -
///   Check that arguments are valid before proceeding
///
/// @return {number} -
///   Total sum of column-units in a grid
@function _su-sum(
  $columns,
  $gutters,
  $spread,
  $validate: true
) {
  @if $validate {
    $columns: su-valid-span($columns);
    $gutters: su-valid-gutters($gutters);
    $spread: su-valid-spread($spread);
  }

  // Calculate column-sum
  $column-sum: 0;
  @each $column in $columns {
    $column-sum: $column-sum + $column;
  }

  $gutter-sum: (ceil(length($columns)) + $spread) * $gutters;
  $total: if(($gutter-sum > 0), $column-sum + $gutter-sum, $column-sum);

  @return $total;
}


// Su Calc
// -------
/// Return a usable span width as a `calc()` function,
/// in order to create mixed-unit grids.
///
/// @group su-math
/// @access private
///
/// @param {number | list} $span -
///   Pre-sliced list of grid columns to span
/// @param {list} $columns -
///   List of columns available
/// @param {number} $gutters -
///   Width of a gutter in column-comparable units
/// @param {0 | 1 | -1} $spread -
///   Number of gutters spanned,
///   relative to `span` count
/// @param {0 | 1 | -1} $container-spread [$spread] -
///   Number of gutters spanned,
///   relative to `columns` count
/// @param {bool} $validate [true] -
///   Check that arguments are valid before proceeding
///
/// @return {length} -
///   Relative or static length of a span on the grid
@function _su-calc-span(
  $span,
  $columns,
  $gutters,
  $spread,
  $container-spread: $spread,
  $validate: true
) {
  @if $validate {
    $span: su-valid-span($span);
    $columns: su-valid-columns($columns);
    $gutters: su-valid-gutters($gutters);
    $spread: su-valid-spread($spread);
    $container-spread: su-valid-spread($container-spread);
  }

  // Span and context
  $span: _su-calc-sum($span, $gutters, $spread, not 'validate');
  $context: _su-calc-sum($columns, $gutters, $container-spread, not 'validate');

  // Fixed and fluid
  $fixed-span: map-get($span, 'fixed');
  $fluid-span: map-get($span, 'fluid');
  $fixed-context: map-get($context, 'fixed');
  $fluid-context: map-get($context, 'fluid');

  $calc: '#{$fixed-span}';
  $fluid-calc: '(100% - #{$fixed-context})';

  // Fluid-values
  @if (not $fluid-span) {
    $fluid-calc: null;
  } @else if ($fluid-span != $fluid-context) {
    $fluid-span: '* #{$fluid-span}';
    $fluid-context: if($fluid-context, '/ #{$fluid-context}', '');
    $fluid-calc: '(#{$fluid-calc $fluid-context $fluid-span})';
  }

  @if $fluid-calc {
    $calc: if(($calc != ''), '#{$calc} + ', '');
    $calc: '#{$calc + $fluid-calc}';
  }

  @return calc(#{unquote($calc)});
}


// Su Calc-Sum
// -----------
/// Get the total sum of fixed and fluid column-units
/// for creating a mixed-unit layout with `calc()` values.
///
/// @group su-math
/// @access private
///
/// @param {list} $columns -
///   List of columns available
/// @param {number} $gutters -
///   Width of a gutter in column-comparable units
/// @param {0 | 1 | -1} $spread -
///   Number of gutters spanned,
///   relative to `span` count
/// @param {bool} $validate [true] -
///   Check that arguments are valid before proceeding
///
/// @return {map} -
///   Map with `fixed` and `fluid` keys
///   containing the proper math as strings
@function _su-calc-sum(
  $columns,
  $gutters,
  $spread,
  $validate: true
) {
  @if $validate {
    $columns: su-valid-span($columns);
    $gutters: su-valid-gutters($gutters);
    $spread: su-valid-spread($spread);
  }

  $fluid: 0;
  $fixed: ();
  $calc: null;

  // Gutters
  $gutters:  $gutters * (length($columns) + $spread);

  // Columns
  @each $col in append($columns, $gutters) {
    @if unitless($col) {
      $fluid: $fluid + $col;
    } @else {
      $fixed: _su-map-add-units($fixed, $col);
    }
  }

  // Compile Fixed Units
  @each $unit, $total in $fixed {
    @if ($total != (0 * $total)) {
      $calc: if($calc, '#{$calc} + #{$total}', '#{$total}');
    }
  }

  // Calc null or string
  @if $calc {
    $calc: if(str-index($calc, '+'), '(#{$calc})', '#{$calc}');
  }

  // Fluid 0 => null
  $fluid: if(($fluid == 0), null, $fluid);


  // Return map
  $return: (
    'fixed': $calc,
    'fluid': $fluid,
  );

  @return $return;
}


// Needs Calc
// ----------
/// Check if `calc()` will be needed in defining a span,
/// if the necessary units in a grid are not comparable.
///
/// @group su-math
/// @access private
///
/// @param {number} $span -
///   Number of grid-columns to be spanned
/// @param {list} $columns -
///   List of available columns in the grid
/// @param {number} $gutters -
///   Width of a gutter
/// @param {bool} $validate [true] -
///   Check that arguments are valid before proceeding
///
/// @return {bool} -
///   `True` when units do not match, and `calc()` will be required
@function _su-needs-calc-output(
  $span,
  $columns,
  $gutters,
  $validate: true
) {
  @if $validate {
    $span: su-valid-span($span);
    $columns: su-valid-columns($columns);
    $gutters: su-valid-gutters($gutters);
  }

  $check: if((length($span) > 1), append($span, $gutters), $span);
  $safe-span: _su-is-comparable($check...);

  @if ($safe-span == 'static') {
    @return false;
  } @else if (not $safe-span) {
    @return true;
  }

  $safe-fluid: _su-is-comparable($gutters, $columns...);

  @return not $safe-fluid;
}


// Settings
// ========
// - susy [variable]
// - susy-defaults [variable]
// - susy-settings [function]
// - susy-get [function]



// Susy
// ----
/// The grid is defined in a single map variable,
/// with four initial properties:
/// `columns`, `gutters`, `spread` and `container-spread`.
/// Anything you put in the root `$susy` variable map
/// will be treated as a global project default.
/// You can create similar configuration maps
/// under different variable names,
/// to override the defaults as-needed.
///
/// @group a-config
/// @type Map
///
/// @see $_susy-defaults
/// @see {function} susy-repeat
/// @link
///   https://codepen.io/mirisuzanne/pen/EgmJJp?editors=1100
///   Spread examples on CodePen
///
/// @prop {list} columns -
///   Columns are described by a list of numbers,
///   representing the relative width of each column.
///   The syntax is a simplified version of CSS native
///   `grid-template-columns`,
///   expecting a list of grid-column widths.
///   Unitless numbers create fractional fluid columns
///   (similar to the CSS-native `fr` unit),
///   while length values (united numbers)
///   are used to define static columns.
///   You can mix-and match units and fractions,
///   to create a mixed grid.
///   Susy will generate `calc()` values when necessary,
///   to make all your units work together.
///
///   Use the `susy-repeat($count, $value)` function
///   to more easily repetative columns,
///   similar to the CSS-native `repeat()`.
///
///   - `susy-repeat(8)`:
///     an 8-column, symmetrical, fluid grid.
///     <br />Identical to `(1 1 1 1 1 1 1 1)`.
///   - `susy-repeat(6, 8em)`:
///     a 6-column, symmetrical, em-based grid.
///     <br />Identical to `(8em 8em 8em 8em 8em 8em)`.
///   - `(300px susy-repeat(4) 300px)`:
///     a 6-column, asymmetrical, mixed fluid/static grid
///     using `calc()` output.
///     <br />Identical to `(300px 1 1 1 1 300px)`.
///
///   **NOTE** that `12` is no longer a valid 12-column grid definition,
///   and you must list all the columns individually
///   (or by using the `susy-repeat()` function).
///
/// @prop {number} gutters -
///   Gutters are defined as a single width,
///   or fluid ratio, similar to the native-CSS
///   `grid-column-gap` syntax.
///   Similar to columns,
///   gutters can use any valid CSS length unit,
///   or unitless numbers to define a relative fraction.
///
///   - `0.5`:
///     a fluid gutter, half the size of a single-fraction column.
///   - `1em`:
///     a static gutter, `1em` wide.
///
///   Mix static gutters with fluid columns, or vice versa,
///   and Susy will generate the required `calc()` to make it work.
///
/// @prop {string} spread [narrow] -
///   Spread of an element across adjacent gutters:
///   either `narrow` (none), `wide` (one), or `wider` (two)
///
///   - Both spread settings default to `narrow`,
///     the most common use-case.
///     A `narrow` spread only has gutters *between* columns
///     (one less gutter than columns).
///     This is how all css-native grids work,
///     and most margin-based grid systems.
///   - A `wide` spread includes the same number of gutters as columns,
///     spanning across a single side-gutter.
///     This is how most padding-based grid systems often work,
///     and is also useful for pushing and pulling elements into place.
///   - The rare `wider` spread includes gutters
///     on both sides of the column-span
///     (one more gutters than columns).
///
/// @prop {string} container-spread [narrow] -
///   Spread of a container around adjacent gutters:
///   either `narrow` (none), `wide` (one), or `wider` (two).
///   See `spread` property for details.
///
/// @example scss - default values
///   // 4 symmetrical, fluid columns
///   // gutters are 1/4 the size of a column
///   // elements span 1 less gutter than columns
///   // containers span 1 less gutter as well
///   $susy: (
///     'columns': susy-repeat(4),
///     'gutters': 0.25,
///     'spread': 'narrow',
///     'container-spread': 'narrow',
///   );
///
/// @example scss - inside-static gutters
///   // 6 symmetrical, fluid columns…
///   // gutters are static, triggering calc()…
///   // elements span equal columns & gutters…
///   // containers span equal columns & gutters…
///   $susy: (
///     'columns': susy-repeat(6),
///     'gutters': 0.5em,
///     'spread': 'wide',
///     'container-spread': 'wide',
///   );
$susy: () !default;



// Susy Repeat
// -----------
/// Similar to the `repeat(<count>, <value>)` function
/// that is available in native CSS Grid templates,
/// the `susy-repeat()` function helps generate repetative layouts
/// by repeating any value a given number of times.
/// Where Susy previously allowed `8` as a column definition
/// for 8 equal columns, you should now use `susy-repeat(8)`.
///
/// @group a-config
///
/// @param {integer} $count -
///   The number of repetitions, e.g. `12` for a 12-column grid.
/// @param {*} $value [1] -
///   The value to be repeated.
///   Technically any value can be repeated here,
///   but the function exists to repeat column-width descriptions:
///   e.g. the default `1` for single-fraction fluid columns,
///   `5em` for a static column,
///   or even `5em 120px` if you are alternating column widths.
///
/// @return {list} -
///   List of repeated values
///
/// @example scss
///   // 12 column grid, with 5em columns
///   $susy: (
///     columns: susy-repeat(12, 5em),
///   );
///
/// @example scss
///   // asymmetrical 5-column grid
///   $susy: (
///     columns: 20px susy-repeat(3, 100px) 20px,
///   );
///
///   /* result: #{susy-get('columns')} */
@function susy-repeat(
  $count,
  $value: 1
) {
  $return: ();

  @for $i from 1 through $count {
    $return: join($return, $value);
  }

  @return $return;
}



// Susy Defaults
// -------------
/// Configuration map of Susy factory defaults.
/// Do not override this map directly –
/// use `$susy` for user and project setting overrides.
///
/// @access private
/// @type Map
///
/// @see $susy
///
/// @prop {number | list} columns [susy-repeat(4)]
/// @prop {number} gutters [0.25]
/// @prop {string} spread ['narrow']
/// @prop {string} container-spread ['narrow']
$_susy-defaults: (
  'columns': susy-repeat(4),
  'gutters': 0.25,
  'spread': 'narrow',
  'container-spread': 'narrow',
);



// Susy Settings
// -------------
/// Return a combined map of Susy settings,
/// based on the factory defaults (`$_susy-defaults`),
/// user-defined project configuration (`$susy`),
/// and any local overrides required –
/// such as a configuration map passed into a function.
///
/// @group a-config
///
/// @param {maps} $overrides… -
///   Optional map override of global configuration settings.
///   See `$susy` above for properties.
///
/// @return {map} -
///   Combined map of Susy configuration settings,
///   in order of specificity:
///   any `$overrides...`,
///   then `$susy` project settings,
///   and finally the `$_susy-defaults`
///
/// @example scss - global settings
///   @each $key, $value in susy-settings() {
///     /* #{$key}: #{$value} */
///   }
///
/// @example scss - local settings
///   $local: ('columns': 1 2 3 5 8);
///
///   @each $key, $value in susy-settings($local) {
///     /* #{$key}: #{$value} */
///   }
@function susy-settings(
  $overrides...
) {
  $settings: map-merge($_susy-defaults, $susy);

  @each $config in $overrides {
    $settings: map-merge($settings, $config);
  }

  @return $settings;
}



// Susy Get
// --------
/// Return the current global value of any Susy setting
///
/// @group a-config
///
/// @param {string} $key -
///   Setting to retrieve from the configuration.
///
/// @return {*} -
///   Value mapped to `$key` in the configuration maps,
///   in order of specificity:
///   `$susy`, then `$_susy-defaults`
///
/// @example scss -
///   /* columns: #{susy-get('columns')} */
///   /* gutters: #{susy-get('gutters')} */
@function susy-get(
  $key
) {
  $settings: susy-settings();

  @if not map-has-key($settings, $key) {
    @return _susy-error(
      'There is no Susy setting called `#{$key}`',
      'susy-get');
  }

  @return map-get($settings, $key);
}


// Parser
// ======
// - susy-normalize [function]
// - susy-normalize-span [function]
// - susy-normalize-columns [function]
// - susy-normalize-spread [function]
// - susy-normalize-location [function]
//
// Susy is divided into two layers:
// "Su" provides the core math functions with a stripped-down syntax,
// while "Susy" adds global settings, shorthand syntax,
// and other helpers.
// This normalization module helps translate between those layers,
// transforming parsed Susy input into
// values that Su will understand.



// Susy Normalize
// --------------
/// Normalize the values in a configuration map.
/// In addition to the global `$susy` properties,
/// this map can include local span-related imformation,
/// like `span` and `location`.
///
/// Normalization does not check that values are valid,
/// which will happen in the Su math layer.
/// These functions merely look for known Susy syntax –
/// returning a map with those shorthand values
/// converted into low-level data for Su.
/// For example `span: all` and `location: first`
/// will be converted into specific numbers.
///
/// @group x-normal
/// @see $susy
/// @see susy-parse
///
/// @param {map} $config -
///   Map of Susy configuration settings to normalize.
///   See `$susy` and `susy-parse()` documentation for details.
/// @param {map | null} $context [null] -
///   Map of Susy configuration settings to use as global reference,
///   or `null` to use global settings.
///
/// @return {map} -
///   Map of Susy configuration settings,
///   with all values normalized for Su math functions.
@function susy-normalize(
  $config,
  $context: null
) {
  // Spread
  @each $setting in ('spread', 'container-spread') {
    $value: map-get($config, $setting);

    @if $value {
      $value: susy-normalize-spread($value);
      $config: map-merge($config, ($setting: $value));
    }
  }

  // Columns
  $columns: map-get($config, 'columns');

  @if $columns {
    $columns: susy-normalize-columns($columns, $context);
    $config: map-merge($config, ('columns': $columns));
  }

  @if not $columns {
    $map: type-of($context) == 'map';
    $columns: if($map, map-get($context, 'columns'), null);
    $columns: $columns or susy-get('columns');
  }

  // Span
  $span: map-get($config, 'span');

  @if $span {
    $span: susy-normalize-span($span, $columns);
    $config: map-merge($config, ('span': $span));
  }

  // Location
  $location: map-get($config, 'location');

  @if $location {
    $location: susy-normalize-location($span, $location, $columns);
    $config: map-merge($config, ('location': $location));
  }

  @return $config;
}



// Normalize Span
// --------------
/// Normalize `span` shorthand for Su.
/// Su span syntax allows an explicit length (e.g. `3em`),
/// unitless column-span number (e.g. `3` columns),
/// or an explicit list of columns (e.g. `(3 5 8)`).
///
/// Susy span syntax also allows the `all` keyword,
/// which will be converted to a slice of the context
/// in normalization.
///
/// @group x-normal
///
/// @param {number | list | 'all'} $span -
///   Span value to normalize.
/// @param {list} $columns -
///   Normalized list of columns in the grid
///
/// @return {number | list} -
///   Number or list value for `$span`
@function susy-normalize-span(
  $span,
  $columns: susy-get('columns')
) {
  @if ($span == 'all') {
    @return length($columns);
  }

  @return $span;
}



// Normalize Columns
// -----------------
/// Normalize `column` shorthand for Su.
/// Su column syntax only allows column lists (e.g. `120px 1 1 1 120px`).
///
/// Susy span syntax also allows a unitless `slice` number (e.g `of 5`),
/// which will be converted to a slice of the context
/// in normalization.
///
/// @group x-normal
///
/// @param {list | integer} $columns -
///   List of available columns,
///   or unitless integer representing a slice of
///   the available context.
/// @param {map | null} $context [null] -
///   Map of Susy configuration settings to use as global reference,
///   or `null` to access global settings.
///
/// @return {list} -
///   Columns list value, normalized for Su input.
///
/// @throws
///   when attempting to access a slice of asymmetrical context
@function susy-normalize-columns(
  $columns,
  $context: null
) {
  $context: $context or susy-settings();

  @if type-of($columns) == 'list' {
    @return _susy-flatten($columns);
  }

  @if (type-of($columns) == 'number') and (unitless($columns)) {
    $span: $columns;
    $context: map-get($context, 'columns');
    $symmetrical: susy-repeat(length($context), nth($context, 1));

    @if ($context == $symmetrical) {
      @return susy-repeat($span, nth($context, 1));
    } @else {
      $actual: 'of `#{$span}`';
      $columns: 'grid-columns `#{$context}`';
      @return _susy-error(
        'context-slice #{$actual} can not be determined based on #{$columns}.',
        'susy-normalize-columns');
    }
  }

  @return $columns;
}



// Normalize Spread
// ----------------
/// Normalize `spread` shorthand for Su.
/// Su spread syntax only allows the numbers `-1`, `0`, or `1` –
/// representing the number of gutters covered
/// in relation to columns spanned.
///
/// Susy spread syntax also allows keywords for each value –
/// `narrow` for `-1`, `wide` for `0`, or `wider` for `1` –
/// which will be converted to their respective integers
/// in normalization.
///
/// @group x-normal
///
/// @param {0 | 1 | -1 | 'narrow' | 'wide' | 'wider'} $spread -
///   Spread across adjacent gutters, relative to a column-count —
///   either `narrow` (-1), `wide` (0), or `wider` (1)
///
/// @return {number} -
///   Numeric value for `$spread`
@function susy-normalize-spread(
  $spread
) {
  $normal-spread: (
    'narrow': -1,
    'wide': 0,
    'wider': 1,
  );

  @return map-get($normal-spread, $spread) or $spread;
}



// Normalize Location
// ------------------
/// Normalize `location` shorthand for Su.
/// Su location syntax requires the (1-indexed) number for a column.
///
/// Susy also allows the `first` and `last` keywords,
/// where `first` is always `1`,
/// and `last` is calculated based on span and column values.
/// Both keywords are normalized into an integer index
/// in normalization.
///
/// @group x-normal
///
/// @param {number} $span -
///   Number of grid-columns to be spanned
/// @param {integer | 'first' | 'last'} $location -
///   Starting (1-indexed) column position of a span,
///   or a named location keyword.
/// @param {list} $columns -
///   Already-normalized list of columns in the grid.
///
/// @return {integer} -
///   Numeric value for `$location`
@function susy-normalize-location(
  $span,
  $location,
  $columns
) {
  $count: length($columns);
  $normal-locations: (
    'first': 1,
    'alpha': 1,
    'last': $count - $span + 1,
    'omega': $count - $span + 1,
  );

  @return map-get($normal-locations, $location) or $location;
}


// Parser
// ======
// - susy-parse [function]



// Parse
// -----
/// The `parse` function provides all the syntax-sugar in Susy,
/// converting user shorthand
/// into a usable map of keys and values
/// that can be normalized and passed to Su.
///
/// @group x-parser
/// @see $susy
///
/// @param {list} $shorthand -
///   Shorthand expression to define the width of the span,
///   optionally containing:
///   - a count, length, or column-list span;
///   - `at $n`, `first`, or `last` location on asymmetrical grids;
///   - `narrow`, `wide`, or `wider` for optionally spreading
///     across adjacent gutters;
///   - `of $n <spread>` for available grid columns
///     and spread of the container
///     (span counts like `of 6` are only valid
///     in the context of symmetrical grids);
///   - and `set-gutters $n` to override global gutter settings
/// @param {bool} $context-only [false] -
///   Allow the parser to ignore span and span-spread values,
///   only parsing context and container-spread.
///   This makes it possible to accept spanless values,
///   like the `gutters()` syntax.
///   When parsing context-only,
///   the `of` indicator is optional.
///
/// @return {map} -
///   Map of span and grid settings
///   parsed from shorthand input –
///   including all the properties available globally –
///   `columns`, `gutters`, `spread`, `container-spread` –
///   along with the span-specific properties
///   `span`, and `location`.
///
/// @throw
///   when a shorthand value is not recognized
@function susy-parse(
  $shorthand,
  $context-only: false
) {
  $parse-error: 'Unknown shorthand property:';
  $options: (
    'first': 'location',
    'last': 'location',
    'alpha': 'location',
    'omega': 'location',
    'narrow': 'spread',
    'wide': 'spread',
    'wider': 'spread',
  );

  $return: ();
  $span: null;
  $columns: null;

  $of: null;
  $next: false;

  // Allow context-only shorthand, without span
  @if ($context-only) and (not index($shorthand, 'of')) {
    @if su-valid-columns($shorthand, 'fail-silent') {
      $shorthand: 'of' $shorthand;
    } @else {
      $shorthand: join('of', $shorthand);
    }
  }

  // loop through the shorthand list
  @for $i from 1 through length($shorthand) {
    $item: nth($shorthand, $i);
    $type: type-of($item);
    $error: false;
    $details: '[#{$type}] `#{$item}`';

    // if we know what's supposed to be coming next…
    @if $next {

      // Add to the return map
      $return: map-merge($return, ($next: $item));

      // Reset next to `false`
      $next: false;

    } @else { // If we don't know what's supposed to be coming…

      // Keywords…
      @if ($type == 'string') {
        // Check the map for keywords…
        @if map-has-key($options, $item) {
          $setting: map-get($options, $item);

          // Spread could be on the span or the container…
          @if ($setting == 'spread') and ($of) {
            $return: map-merge($return, ('container-spread': $item));
          } @else {
            $return: map-merge($return, ($setting: $item));
          }

        } @else if ($item == 'all') {
          // `All` is a span shortcut
          $span: 'all';
        } @else if ($item == 'at') {
          // Some keywords setup what's next…
          $next: 'location';
        } @else if ($item == 'set-gutters') {
          $next: 'gutters';
        } @else if ($item == 'of') {
          $of: true;
        } @else {
          $error: true;
        }

      } @else if ($type == 'number') or ($type == 'list') { // Numbers & lists…

        @if not ($span or $of) {
          // We don't have a span, and we're not expecting context…
          $span: $item;
        } @else if ($of) and (not $columns) {
          // We are expecting context…
          $columns: $item;
        } @else {
          $error: true;
        }

      } @else {
        $error: true;
      }
    }

    @if $error {
      @return _susy-error('#{$parse-error} #{$details}', 'susy-parse');
    }
  }

  // If we have span, merge it in
  @if $span {
    $return: map-merge($return, ('span': $span));
  }

  // If we have columns, merge them in
  @if $columns {
    $return: map-merge($return, ('columns': $columns));
  }

  // Return the map of settings…
  @return $return;
}


// Syntax Utilities
// ================
// - susy-compile [function]
// - su-call [function]
//
// There are many steps involved
// when translating between the Susy syntax layer,
// and the Su core math.
// That entire process can be condensed with these two functions.
// For anyone that wants to access the full power of Susy,
// and build their own plugins, functions, and mixins –
// this is the primary API for compiling user input,
// and accessing the core math.


// Compile
// -------
/// Susy's syntax layer has various moving parts,
/// with syntax-parsing for the grid/span shorthand,
/// and normalization for each of the resulting values.
/// The compile function rolls this all together
/// in a single call –
/// for quick access from our internal API functions,
/// or any additional functions and mixins you add to your project.
/// Pass user input and configuration maps to the compiler,
/// and it will hand back a map of values ready for Su.
/// Combine this with the `su-call` function
/// to quickly parse, normalize, and process grid calculations.
///
/// @group plugin-utils
/// @see su-call
///
/// @param {list | map} $shorthand -
///   Shorthand expression to define the width of the span,
///   optionally containing:
///   - a count, length, or column-list span;
///   - `at $n`, `first`, or `last` location on asymmetrical grids;
///   - `narrow`, `wide`, or `wider` for optionally spreading
///     across adjacent gutters;
///   - `of $n <spread>` for available grid columns
///     and spread of the container
///     (span counts like `of 6` are only valid
///     in the context of symmetrical grids);
///   - and `set-gutters $n` to override global gutter settings
/// @param {map} $config [null] -
///   Optional map of Susy grid configuration settings
/// @param {bool} $context-only [false] -
///   Allow the parser to ignore span and span-spread values,
///   only parsing context and container-spread
///
/// @return {map} -
///   Parsed and normalized map of settings,
///   based on global and local configuration,
///   alongwith shorthad adjustments.
///
/// @example scss -
///   $user-input: 3 wide of susy-repeat(6, 120px) set-gutters 10px;
///   $grid-data: susy-compile($user-input, $susy);
///
///   @each $key, $value in $grid-data {
///     /* #{$key}: #{$value}, */
///   }
@function susy-compile(
  $short,
  $config: null,
  $context-only: false
) {
  // Get and normalize config
  $config: if($config, susy-settings($config), susy-settings());
  $normal-config: susy-normalize($config);

  // Parse and normalize shorthand
  @if (type-of($short) != 'map') and (length($short) > 0) {
    $short: susy-parse($short, $context-only);
  }

  $normal-short: susy-normalize($short, $normal-config);

  // Merge and return
  @return map-merge($normal-config, $normal-short);
}



// Call
// ----
/// The Susy parsing and normalization process
/// results in a map of configuration settings,
/// much like the global `$susy` settings map.
/// In order to pass that information along to Su math functions,
/// the proper values have to be picked out,
/// and converted to arguments.
///
/// The `su-call` function streamlines that process,
/// weeding out the unnecessary data,
/// and passing the rest along to Su in the proper format.
/// Combine this with `susy-compile` to quickly parse,
/// normalize, and process grid calculations.
///
/// @group plugin-utils
///
/// @require su-span
/// @require su-gutter
/// @require su-slice
/// @see susy-compile
///
/// @param {'su-span' | 'su-gutter' | 'su-slice'} $name -
///   Name of the Su math function to call.
/// @param {map} $config -
///   Parsed and normalized map of Susy configuration settings
///   to use for math-function arguments.
///
/// @return {*} -
///   Results of the function being called.
///
/// @example scss -
///   $user-input: 3 wide of susy-repeat(6, 120px) set-gutters 10px;
///   $grid-data: susy-compile($user-input, $susy);
///
///   .su-span {
///     width: su-call('su-span', $grid-data);
///   }
@function su-call(
  $name,
  $config
) {
  $grid-function-args: (
    'su-span': ('span', 'columns', 'gutters', 'spread', 'container-spread', 'location'),
    'su-gutter': ('columns', 'gutters', 'container-spread'),
    'su-slice': ('span', 'columns', 'location'),
  );

  $args: map-get($grid-function-args, $name);

  @if not $args {
    $options: 'Try one of these: #{map-keys($grid-function-args)}';
    @return _susy-error(
      '#{$name} is not a public Su function. #{$options}',
      'su-call');
  }

  $call: if(function-exists('get-function'), get-function($name), $name);
  $output: ();

  @each $arg in $args {
    $value: map-get($config, $arg);
    $output: if($value, map-merge($output, ($arg: $value)), $output);
  }

  @return call($call, $output...);
}


// Grids
// =====
// - susy-span [function]
// - susy-gutter [function]
// - susy-slice [function]
//
// These three functions form the core of Susy's
// layout-building API.
// Get the width of a `span()` or `gutter()`
// on any given `slice` of your grid –
// and apply the results anywhere you need them:
// CSS `width`, `margin`, `padding`, `flex-basis`, `transform`, etc.
// Anything you can do in CSS,
// Susy is just here to help with the math.
//
// - All three functions come with an unprefixed alias by default,
//   with the `susy` import.
//   Import the `susy-prefix` partial instead,
//   if you only only want prefixed versions of the API.
//
// - This is a thin syntax-sugar shell around
//   the "Su" core-math functions: `su-span`, `su-gutter`, and `su-slice`.
//   If you prefer the more constrained syntax of the math engine,
//   you are welcome to use those functions instead.


// Susy Span
// ---------
/// This is the primary function in Susy —
/// used to return the width of a span across one or more columns,
/// and any relevant gutters along the way.
/// With the default settings,
/// `span(3)` will return the width of 3 columns,
/// and the 2 intermediate gutters.
/// This can be used to set the `width` property of grid elements,
/// or `margin` and `padding`
/// to push, pull, and pad your elements.
///
/// - This is a thin syntax-sugar shell around
///   the core-math `su-span()` function.
/// - The un-prefixed alias `span()` is available by default.
///
/// @group b-api
/// @see su-span
/// @see $susy
///
/// @param {list} $span -
///   Shorthand expression to define the width of the span,
///   optionally containing:
///   - a count, length, or column-list span.
///   - `at $n`, `first`, or `last` location on asymmetrical grids,
///     where `at 1 == first`,
///     and `last` will calculate the proper location
///     based on columns and span.
///   - `narrow`, `wide`, or `wider` for optionally spreading
///     across adjacent gutters.
///   - `of $n <spread>` for available grid columns
///     and spread of the container.
///     Span counts like `of 6` are valid
///     in the context of symmetrical grids,
///     where Susy can safely infer a slice of the parent columns.
///   - and `set-gutters $n` to override global gutter settings.
///
/// @param {map} $config [()] -
///   Optional map of Susy grid configuration settings.
///   See `$susy` documentation for details.
///
/// @return {length} -
///   Calculated length value, using the units given,
///   or converting to `%` for fraction-based grids,
///   or a full `calc` function when units/fractions
///   are not comparable outside the browser.
///
/// @example scss - span half the grid
///   .foo {
///     // the result is a bit under 50% to account for gutters
///     width: susy-span(6 of 12);
///   }
///
/// @example scss - span a specific segment of asymmetrical grid
///   .foo {
///     width: susy-span(3 at 3 of (1 2 3 5 8));
///   }
@function susy-span(
  $span,
  $config: ()
) {
  $output: susy-compile($span, $config);

  @if map-get($output, 'span') {
    @return su-call('su-span', $output);
  }

  $actual: '[#{type-of($span)}] `#{inspect($span)}`';
  @return _susy-error(
    'Unable to determine span value from #{$actual}.',
    'susy-span');
}


// Susy Gutter
// -----------
/// The gutter function returns
/// the width of a single gutter on your grid,
/// to be applied where you see fit –
/// on `margins`, `padding`, `transform`, or element `width`.
///
/// - This is a thin syntax-sugar shell around
///   the core-math `su-gutter()` function.
/// - The un-prefixed alias `gutter()` is available by default.
///
/// @group b-api
/// @see su-gutter
/// @see $susy
///
/// @param {list | number} $context [null] -
///   Optional context for nested gutters,
///   including shorthand for
///   `columns`, `gutters`, and `container-spread`
///   (additional shorthand will be ignored)
///
/// @param {map} $config [()] -
///   Optional map of Susy grid configuration settings.
///   See `$susy` documentation for details.
///
/// @return {length} -
///   Width of a gutter as `%` of current context,
///   or in the units defined by `column-width` when available
///
/// @example scss - add gutters before or after an element
///   .floats {
///     float: left;
///     width: span(3 of 6);
///     margin-left: gutter(of 6);
///   }
///
/// @example scss - add gutters to padding
///   .flexbox {
///     flex: 1 1 span(3 wide of 6 wide);
///     padding: gutter(of 6) / 2;
///   }
///
@function susy-gutter(
  $context: susy-get('columns'),
  $config: ()
) {
  $context: susy-compile($context, $config, 'context-only');

  @return su-call('su-gutter', $context);
}


// Susy Slice
// ----------
/// Working with asymmetrical grids (un-equal column widths)
/// can be challenging – 
/// expecially when they involve fluid/fractional elements.
/// Describing a context `of (15em 6em 6em 6em 15em)` is a lot
/// to put inside the span or gutter function shorthand.
/// This slice function returns a sub-slice of asymmetrical columns to use
/// for a nested context.
/// `slice(3 at 2)` will give you a subset of the global grid,
/// spanning 3 columns, starting with the second.
///
/// - This is a thin syntax-sugar shell around
///   the core-math `su-slice()` function.
/// - The un-prefixed alias `slice()` is available by default.
///
/// @group b-api
/// @see su-slice
/// @see $susy
///
/// @param {list} $span -
///   Shorthand expression to define the subset span, optionally containing:
///   - `at $n`, `first`, or `last` location on asymmetrical grids;
///   - `of $n <spread>` for available grid columns
///     and spread of the container
///     - Span-counts like `of 6` are only valid
///       in the context of symmetrical grids
///     - Valid spreads include `narrow`, `wide`, or `wider`
///
/// @param {map} $config [()] -
///   Optional map of Susy grid configuration settings.
///   See `$susy` documentation for details.
///
/// @return {list} -
///   Subset list of columns for use for a nested context
///
/// @example scss - Return a nested segment of asymmetrical grid
///   $context: susy-slice(3 at 3 of (1 2 3 5 8));
///   /* $context: #{$context}; */
@function susy-slice(
  $span,
  $config: ()
) {
  $span: susy-compile($span, $config);

  @return su-call('su-slice', $span);
}


// Unprefix Susy
// =============


// Span
// ----
/// Un-prefixed alias for `susy-span`
/// (available by default)
///
/// @group api
/// @alias susy-span
///
/// @param {list} $span
/// @param {map} $config [()]
@function span(
  $span,
  $config: ()
) {
  @return susy-span($span, $config);
}


// Gutter
// ------
/// Un-prefixed alias for `susy-gutter`
/// (available by default)
///
/// @group api
/// @alias susy-gutter
///
/// @param {integer | list} $context [null] -
/// @param {map} $config [()]
@function gutter(
  $context: susy-get('columns'),
  $config: ()
) {
  @return susy-gutter($context, $config);
}


// Slice
// -----
/// Un-prefixed alias for `susy-slice`
/// (available by default)
///
/// @group api
/// @alias susy-slice
///
/// @param {list} $span
/// @param {map} $config [()]
@function slice(
  $span,
  $config: ()
) {
  @return susy-slice($span, $config);
}
